"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.baseBuildInfo = baseBuildInfo;
exports.buildInfo = buildInfo;
exports.getGlibcVersion = getGlibcVersion;
const os_1 = __importDefault(require("os"));
const service_provider_node_driver_1 = require("@mongosh/service-provider-node-driver");
const fs_1 = require("fs");
function getSystemArch() {
    return process.platform === 'darwin'
        ? os_1.default.cpus().some((cpu) => {
            return /Apple/.test(cpu.model);
        })
            ? 'arm64'
            : 'x64'
        : process.arch;
}
async function getInstallationMethod(info) {
    var _a;
    if (info.distributionKind !== 'compiled') {
        if (process.env.npm_lifecycle_event === 'npx' &&
            ((_a = process.env.npm_lifecycle_script) === null || _a === void 0 ? void 0 : _a.includes('mongosh')))
            return 'npx';
        if (__filename.match(/\bhomebrew\b/i) &&
            process.execPath.match(/\bhomebrew\b/i))
            return 'homebrew';
    }
    else {
        if (info.buildPlatform === 'linux' &&
            process.execPath.startsWith('/usr/bin/') &&
            (await fs_1.promises.stat(process.execPath)).uid === 0) {
            return 'linux-system-wide';
        }
    }
    return 'other';
}
function baseBuildInfo() {
    var _a;
    const runtimeData = {
        nodeVersion: process.version,
        opensslVersion: process.versions.openssl,
        sharedOpenssl: !!process.config.variables.node_shared_openssl,
        runtimeArch: getSystemArch(),
        runtimePlatform: process.platform,
        runtimeGlibcVersion: (_a = getGlibcVersion()) !== null && _a !== void 0 ? _a : 'N/A',
    };
    try {
        return {
            ...require('./build-info.json'),
            ...runtimeData,
        };
    }
    catch (_b) {
        const { version } = require('../package.json');
        return {
            version,
            distributionKind: 'unpackaged',
            buildArch: process.arch,
            buildPlatform: process.platform,
            buildTarget: 'unknown',
            buildTime: null,
            gitVersion: null,
            ...runtimeData,
        };
    }
}
async function buildInfo({ withSegmentApiKey, } = {}) {
    const dependencyVersionInfo = {
        ...service_provider_node_driver_1.NodeDriverServiceProvider.getVersionInformation(),
    };
    const buildInfo = { ...baseBuildInfo(), deps: { ...dependencyVersionInfo } };
    if (!withSegmentApiKey) {
        delete buildInfo.segmentApiKey;
    }
    return {
        installationMethod: await getInstallationMethod(buildInfo),
        ...buildInfo,
    };
}
let cachedGlibcVersion = null;
function getGlibcVersion() {
    if (process.platform !== 'linux')
        return undefined;
    if (cachedGlibcVersion !== null)
        return cachedGlibcVersion;
    try {
        return (cachedGlibcVersion = require('glibc-version')());
    }
    catch (_a) {
        return (cachedGlibcVersion = undefined);
    }
}
//# sourceMappingURL=build-info.js.map
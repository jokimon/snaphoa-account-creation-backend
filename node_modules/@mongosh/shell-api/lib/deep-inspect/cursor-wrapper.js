"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepInspectCursorWrapper = deepInspectCursorWrapper;
const custom_inspect_1 = require("./custom-inspect");
function deepInspectCursorWrapper(_cursor) {
    const cursor = _cursor;
    return {
        get [Symbol.for('@@mongosh.originalCursor')]() {
            return cursor;
        },
        allowDiskUse: forwardedMethod('allowDiskUse', cursor),
        collation: forwardedMethod('collation', cursor),
        comment: forwardedMethod('comment', cursor),
        maxAwaitTimeMS: forwardedMethod('maxAwaitTimeMS', cursor),
        count: forwardedMethod('count', cursor),
        hint: forwardedMethod('hint', cursor),
        max: forwardedMethod('max', cursor),
        min: forwardedMethod('min', cursor),
        limit: forwardedMethod('limit', cursor),
        skip: forwardedMethod('skip', cursor),
        returnKey: forwardedMethod('returnKey', cursor),
        showRecordId: forwardedMethod('showRecordId', cursor),
        project: forwardedMethod('project', cursor),
        sort: forwardedMethod('sort', cursor),
        explain: forwardedMethod('explain', cursor),
        addCursorFlag: forwardedMethod('addCursorFlag', cursor),
        withReadPreference: cursor.withReadPreference
            ? (readPreference) => {
                cursor.withReadPreference(readPreference);
                return cursor;
            }
            : undefined,
        withReadConcern: cursor.withReadConcern
            ? (readConcern) => {
                cursor.withReadConcern(readConcern);
                return cursor;
            }
            : undefined,
        batchSize: forwardedMethod('batchSize', cursor),
        hasNext: forwardedMethod('hasNext', cursor),
        close: forwardedMethod('close', cursor),
        maxTimeMS: forwardedMethod('maxTimeMS', cursor),
        bufferedCount: forwardedMethod('bufferedCount', cursor),
        next: forwardResultPromise('next', cursor),
        tryNext: forwardResultPromise('tryNext', cursor),
        toArray: forwardResultPromise('toArray', cursor),
        readBufferedDocuments: forwardResults('readBufferedDocuments', cursor),
        get closed() {
            return cursor.closed;
        },
        get resumeToken() {
            return cursor.resumeToken;
        },
        [Symbol.asyncIterator]: cursor[Symbol.asyncIterator]
            ? async function* () {
                for await (const doc of cursor[Symbol.asyncIterator]()) {
                    (0, custom_inspect_1.addCustomInspect)(doc);
                    yield doc;
                }
            }
            : undefined,
    };
}
function forwardResultPromise(key, cursor) {
    if (!cursor[key])
        return undefined;
    return async function (...args) {
        const result = await cursor[key](...args);
        if (result) {
            (0, custom_inspect_1.addCustomInspect)(result);
        }
        return result;
    };
}
function forwardResults(key, cursor) {
    if (!cursor[key])
        return undefined;
    return function (...args) {
        const results = cursor[key](...args);
        (0, custom_inspect_1.addCustomInspect)(results);
        return results;
    };
}
function forwardedMethod(key, cursor) {
    if (!cursor[key])
        return undefined;
    return function (...args) {
        return cursor[key](...args);
    };
}
//# sourceMappingURL=cursor-wrapper.js.map